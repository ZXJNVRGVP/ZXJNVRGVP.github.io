{"pages":[],"posts":[{"title":"P1196","text":"算法：带权并查集这道题有两种算法，但主要思想都是并查集，区别在于是否有路径压缩。 1. 不带路径压缩 此时fa[x]就表示排在第x号战舰前面的那个战舰的编号。集合的“代表”就是最前面的战舰的编号。 让树上每条边带上权值1，这样树上两点之间的距离-1就是二者相隔的战舰数量。 注意，这样写的话在find函数中就不能加上路径压缩的优化。 2.带路径压缩 在考虑路径压缩时，我们应该在建立一个数组d，d[x]记录战舰x与fa[x]之间的边的权值。 我们知道，在路径压缩时，会把x指向此时的树根。我们应该对find函数做一些修改，把d[x]更新为从x到树根的路径上的所有边权之和。 inline int find(int x) { if(x==f[x]) return x; int root=find(f[x]); d[x]+=d[f[x]]; return f[x]=root; } 当接收到Cxy指令时，分别执行find(x),find(y)完成查询和路径压缩。如果两者的返回值相同，则说明x,y在同一列之中。 那么，d[x]和d[y]都指向了共同的树根，分别表示在x，y之前的战舰数量。二者之差再减1就是x和y之间间隔的战舰数量。 当接收到Mxy指令时，把x的树根作为y的树根的子节点，连接的新边的权值应给设为合并之前集合y的大小。（因为y集合全部排在x之前） 因此还需要增加一个size数组记录每个集合的大小。 void merge(int x,int y) { x=find(x);y=find(y); f[x]=y;d[x]=size[y]; size[y]+=size[x]; } 下面是完整代码 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; using namespace std; const int N=30000; int t,f[N+5],d[N+5],size[N+5]; inline int find(int x) { if(x==f[x]) return x; int root=find(f[x]); d[x]+=d[f[x]]; return f[x]=root; } void merge(int x,int y) { x=find(x);y=find(y); f[x]=y;d[x]=size[y]; size[y]+=size[x]; } int main() { cin&gt;&gt;t; char o;int i,j; for(int i=1;i&lt;=N;i++) { f[i]=i; d[i]=0; size[i]=1; } while(t--) { cin&gt;&gt;o&gt;&gt;i&gt;&gt;j; if(o=='M') merge(i,j); if(o=='C') { int x=find(i),y=find(j); if(x!=y) { cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; continue; } else { int q=abs(d[i]-d[j])-1; cout&lt;&lt;q&lt;&lt;endl; } } } return 0; }","link":"/P1196/"},{"title":"题解 CF475B 【Strongly Connected City】","text":"​ 其实只要稍加思考便可以发现一个这张图的一个特性：只要边缘的四个点是相连通的，整张图就是联通的 ​ 根据题意，可以发现，图中的任何一个节点，都可以通过在边缘的四条边中的某个点直接抵达（一溜就到了）。 ​ 如果四个顶点相连通，就代表四条边缘的边上的点都可以通过顶点到达，而中间的点只要顺着所处的边的方向走一点可以到边缘，所以所有点都可以到所有点。 ​ 相反的，如果有四角上的顶点从相邻的四角上的顶点无法到达，也就意味着所有点都到不了这个顶点（因为只有两条边连着外面）。 ​ 因此只要判断四个顶点上的边方向看是否联通即可。 #include &lt;iostream&gt; #include &quot;cstdio&quot; #include &quot;cstring&quot; using namespace std; int n, m, din[22], dim[22]; bool ans = true; string a, b; int main(int argc, char const *argv[]) { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); cin&gt;&gt;a&gt;&gt;b; for (int i = 0; i &lt; n; i++) if (a[i]=='&gt;') din[i+1] = 1; for (int i = 0; i &lt; m; i++) if (b[i]=='^') dim[i+1] = 1; if (din[1] != dim[1]) ans = false; if (din[1] == dim[m]) ans = false; if (din[n] == dim[1]) ans = false; if (din[n] != dim[m]) ans = false; if (ans) cout&lt;&lt;&quot;YES&quot;; else cout&lt;&lt;&quot;NO&quot;; return 0; }","link":"/Strongly Conected City/"},{"title":"Tarjan有向图缩点","text":"","link":"/Tarjan/"},{"title":"题解 luogu P1455 【搭配购买】","text":"正解​ 正解十分简单。所有互相有关联的云可以视作捆绑销售，使用并查集合在一起，得到若干个由原来的物品组成的新物品，最后跑01背包即可。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N=10005; int n,m,w,val[N],wor[N],f[N],fa[N]; int p[N],v[N],id[N],tot; bool vis[N]; inline int get() { int res=0;char c=getchar(); while(c&lt;'0'||c&gt;'9') c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9') { res=res*10+c-'0'; c=getchar(); } return res; } int find(int x) { if(x==fa[x]) return x; else return fa[x]=find(fa[x]); } int main() { n=get(),m=get(),w=get(); for(int i=1;i&lt;=n;i++) wor[i]=get(),val[i]=get(); for(int i=1;i&lt;=n;i++) fa[i]=i; int x,y,fi; for(int i=1;i&lt;=m;i++) { x=get(),y=get(); int fx=find(x),fy=find(y); if(fx!=fy) fa[fx]=fy; } for(int i=1;i&lt;=n;i++) { fi=find(i); if(!vis[fi]) { tot++; id[fi]=tot; v[tot]+=val[i]; p[tot]+=wor[i]; vis[fi]=true; } else { v[id[fi]]+=val[i]; p[id[fi]]+=wor[i]; } } for(int i=1;i&lt;=tot;i++) for(int j=w;j&gt;=p[i];j--) f[j]=max(f[j],f[j-p[i]]+v[i]); int ans=0; for(int i=0;i&lt;=w;i++) ans=max(ans,f[i]); printf(&quot;%d&quot;,ans); return 0; } 来个复杂点的解法思路：Tarjan缩点+01背包 我知道并查集就可以惹qwq，但不知为何写了个tarjan 反正思路很简单，tarjan缩点，缩出来的点就是有关系的点揉在一起的，再在新点上进行01背包。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #define ll long long using namespace std; const int N=1e4+100; int c[N],d[N],cost[N],val[N]; int next[N],head[N],go[N],tot; inline void add(int u,int v){ next[++tot]=head[u];head[u]=tot;go[tot]=v; next[++tot]=head[v];head[v]=tot;go[tot]=u; } int dfn[N],st[N],low[N],co[N],col,num,top; int Tarjan(int u){ dfn[u]=low[u]=++num; st[++top]=u; for(int i=head[u],v;i;i=next[i]){ v=go[i]; if(!dfn[v]){ Tarjan(v); low[u]=min(low[u],low[v]); }else if(!co[v]){ low[u]=min(low[u],dfn[v]); } } if(low[u]==dfn[u]){ co[u]=++col; cost[col]+=c[u]; val[col]+=d[u]; while(st[top]!=u){ cost[col]+=c[st[top]]; val[col]+=d[st[top]]; co[st[top]]=col; --top; } --top; } } int f[2][N]; int main(){ freopen(&quot;buy.in&quot;,&quot;r&quot;,stdin); freopen(&quot;buy.out&quot;,&quot;w&quot;,stdout); int n,m,w; cin&gt;&gt;n&gt;&gt;m&gt;&gt;w; for(int i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;c[i],&amp;d[i]); for(int i=1,u,v;i&lt;=m;i++){ scanf(&quot;%d%d&quot;,&amp;u,&amp;v); add(u,v); } for(int i=1;i&lt;=n;i++) if(!dfn[i])Tarjan(i); memset(f,0xcf,sizeof(f)); f[0][0]=0; for(int i=1;i&lt;=col;i++){ for(int j=0;j&lt;=w;j++) f[i&amp;1][j]=f[(i-1)&amp;1][j]; for(int j=cost[i];j&lt;=w;j++) f[i&amp;1][j]=max(f[(i-1)&amp;1][j],f[(i-1)&amp;1][j-cost[i]]+val[i]); } int ans=0; for(int j=0;j&lt;=w;j++) ans=max(ans,f[col&amp;1][j]); cout&lt;&lt;ans&lt;&lt;endl; }","link":"/搭配购买/"},{"title":"欢迎来到我的博客！","text":"这里是ZXJ_Hans的博客，我会在这里记录_各种东西_，欢迎来看。","link":"/欢迎页/"},{"title":"二分图最大匹配","text":"定义 匹配：任意两条边都没有公共端点的边的集合被称为图的一组匹配。 最大匹配：在二分图中，包含边数最多的一组匹配。 匹配边与非匹配边：对于任意一组匹配S，属于S的边被称为匹配边，不属于S的被称为非匹配边。 匹配点与非匹配点：匹配边的端点被称为匹配点，非匹配边的端点被称为非匹配点。 增广路：连结两个非匹配点的路径，使得非匹配边与匹配边交替出现。 完备匹配:给定一张二分图，其左部、右部端点数量都为N，如果该二分图的最大匹配包含N条匹配边，则称该二分图具有完备匹配。 接下来我们看几张图来帮助理解。 如图2，这是一个二分图。 如图3，所有红色的边就是该二分图的一组匹配。很显然，两条红色的边都没有公共端点。 再看图4，此时所有红色的边组成的也是一组匹配，而且是最大匹配，甚至还是完备匹配。因为匹配边的数量不能再多了，而且匹配边的数量和左右部端点数相同。 如图5，又是一张二分图，红色边的是一组匹配，红色的点就是匹配点了。 如图6，就是图5的一条增广路了，可以看到，第一个端点和最后一个端点都是非匹配点，途中经过的边是非匹配边，匹配边的方式交替的。 问题关于二分图匹配的问题，最常见的应该就是求二分图的最大匹配了吧。。。 举个例子，看这张图： 图中男女可以凑成一对的被连上了边，那我们要尽可能的促成他人的爱情，抽象出来，也就是求二分图最大匹配了。 （虽然我觉得这样的人际关系很渣，但没办法它是服务于学术的呢。。。） 为了解决这么一个渣男渣女问题，我们需要用到一个和这个问题一样让人感觉不太舒服的算法（笑。 匈牙利算法匈牙利算法，又称增广路算法，顾名思义，运用到了增广路的性质，这里就对增广路的一些性质进行补充。 增广路的性质（建议结合上面增广路的定义看） 长度为奇数，这是显然的，因为是交替的嘛。 路径上第奇数号的边是非匹配边，偶数号的是匹配边。 看到以上性质，你有没有明白些什么？？ 没有，好，那就容我BB两句。有我也要BB 如果我们把增广路上的每条边状态取反，就能得到一个新匹配S’，而且比原来的匹配S大了1！ 进一步我们可以得到推论： ==二分图的一组匹配S是最大匹配，当且仅当图中不存在S的增广路。== 算法流程有了以上知识，我们可以开始看匈牙利算法的过程了： 设S为空集，即所有边都是非匹配边。 寻找增广路，再把路径上所有边的匹配状态取反，得到了一个更大的匹配S’。 算法的关键在于，怎么找到一条增广路。 事实上这还是挺简单的，也没啥高深思想。就是尝试给每个左部节点去找右部节点来匹配。右部节点y能与左部节点x匹配，需要满足下列条件之一： y本身就是非匹配点。此时边(x,y)本身就是一条增广路了，长度为1。 y已经和左部节点x’匹配了，但可以从x’出发找到另一个右部节点y’与之匹配。那我们就把x’和y’连上，再连x和y。这样，x-&gt;y-&gt;x’-&gt;y’就构成了一条增广路。 程序方面，这里是用深度优先搜索实现的。递归地从x出发寻找增广路，如果找到了，就在回溯的同时对沿路的边进行取反。还要同时用全局vis数组来记录访问状态，避免重复搜索。 这里再推荐一个简单易懂的文章，不清楚的同学可以再去看看。 匈牙利算法的正确性基于贪心思想，因为一旦一个点成为了匹配点，至多因为找到增广路而更换匹配对象，不会再变回非匹配点。 代码实现bool dfs(int x) { for(int e=head[x];e;e=nxt[e]) { int y=ver[e]; if(vis[y]) continue; if(!match[y]||dfs(match[y])) //match记录匹配点 { match[y]=x; //修改匹配点，递归查找增广路 return true; } } return false; } int main() { for(int i=1;i&lt;=n;i++) { memset(vis,0,sizeof(vis)); //每次搜完记得初始化访问状态 if(dfs(i)) ans++; } } 适用情况二分图匹配能适用的模型有两个要素： 节点能分成两个独立的集合，每个集合内部有0条边。 每个节点只能与1条匹配边相连。 同时满足以上两个要素，就该考虑使用二分图匹配了。","link":"/匈牙利算法/"}],"tags":[{"name":"-题解","slug":"题解","link":"/tags/题解/"},{"name":"图论","slug":"图论","link":"/tags/图论/"},{"name":"dp","slug":"dp","link":"/tags/dp/"},{"name":"并查集","slug":"并查集","link":"/tags/并查集/"},{"name":"欢迎","slug":"欢迎","link":"/tags/欢迎/"}],"categories":[{"name":"题解","slug":"题解","link":"/categories/题解/"},{"name":"算法","slug":"算法","link":"/categories/算法/"}]}