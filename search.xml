<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>题解 P1130 【红牌】</title>
      <link href="/%E9%A2%98%E8%A7%A3%20P1130%20%E3%80%90%E7%BA%A2%E7%89%8C%E3%80%91/"/>
      <url>/%E9%A2%98%E8%A7%A3%20P1130%20%E3%80%90%E7%BA%A2%E7%89%8C%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="我的博客"><a href="#我的博客" class="headerlink" title="我的博客"></a><a href="zxjnvrgvp.github.io">我的博客</a></h1><p>以上是打广告</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>分析题意，一个格子能选择往正右走还是右下走，求到最后一列得到的最小值。</p><p>设<code>f[N][N]</code>为dp数组，<code>f[j][i]</code>代表走到第<code>j</code>行第<code>i</code>列时可能得到的最小值。我们可以得到状态转移方程：<br>$$ f[j][i]=min(f[j][i-1],f[j-1][i-1])+a[j][i] $$</p><p>代表状态从左方或左上方传递过来，应注意当<code>j==1</code>时，<code>f[j-1][i-1]</code>应该替换为<code>f[m][i-1]</code>。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"iostream"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"cstdio"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"cstring"</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">2005</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> ans <span class="token operator">=</span> <span class="token number">0x3f3f3f3f</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>                f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        ans <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> ans<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 信息竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P1104 【生日】</title>
      <link href="/%E9%A2%98%E8%A7%A3%20P1104%20%E3%80%90%E7%94%9F%E6%97%A5%E3%80%91/"/>
      <url>/%E9%A2%98%E8%A7%A3%20P1104%20%E3%80%90%E7%94%9F%E6%97%A5%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="Hanzire-的博客"><a href="#Hanzire-的博客" class="headerlink" title="Hanzire 的博客"></a><a href="https://zxjnvrgvp.github.io/">Hanzire 的博客</a></h1><p>以上是打广告↑↑↑</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>我的思路很简单，直接把年月日处理成一个数字，之间排序就OK。</p><p>怎么处理呢？</p><p>年，月，日，按顺序拼接，如果是0几月，0几日，就在那一位补0。这样从高位看下来，就符合从小往大排序的标准了。具体就是年×10000，后面多出4个0用来补位，月×100，再三者加起来。</p><p>但要注意还是要记录读入的顺序，假如生日相同就用读入顺序判断吧。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"iostream"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"algorithm"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"cstdio"</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">struct</span> node<span class="token punctuation">{</span>    <span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> birthday<span class="token punctuation">,</span> order<span class="token punctuation">;</span><span class="token punctuation">}</span> a<span class="token punctuation">[</span><span class="token number">105</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">inline</span> <span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span>node x<span class="token punctuation">,</span> node y<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>birthday <span class="token operator">==</span> y<span class="token punctuation">.</span>birthday<span class="token punctuation">)</span>        <span class="token keyword">return</span> x<span class="token punctuation">.</span>order <span class="token operator">></span> y<span class="token punctuation">.</span>order<span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">.</span>birthday <span class="token operator">&lt;</span> y<span class="token punctuation">.</span>birthday<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s%d%d%d"</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>s<span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>y<span class="token punctuation">,</span> <span class="token operator">&amp;</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>birthday <span class="token operator">=</span> x <span class="token operator">*</span> <span class="token number">10000</span> <span class="token operator">+</span> y <span class="token operator">*</span> <span class="token number">100</span> <span class="token operator">+</span> z<span class="token punctuation">;</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>order <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">sort</span><span class="token punctuation">(</span>a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> a <span class="token operator">+</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>s <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 信息竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P1125 【笨小猴】</title>
      <link href="/%E9%A2%98%E8%A7%A3%20P1125%20%E3%80%90%E7%AC%A8%E5%B0%8F%E7%8C%B4%E3%80%91/"/>
      <url>/%E9%A2%98%E8%A7%A3%20P1125%20%E3%80%90%E7%AC%A8%E5%B0%8F%E7%8C%B4%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="我的博客"><a href="#我的博客" class="headerlink" title="我的博客"></a><a href="zxjnvrgvp.github.io">我的博客</a></h1><p>以上是广告↑↑↑</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>用最原始的字符数组读入，因为只出现小写字母，所以可以用字符-‘a’来作为桶数组的下标来储存每个字母出现的次数。</p><p>然后筛选最大的元素和除0之外最小的元素。相减得到ans,最后判断一下素数。我这里用的是埃筛法，其实这里数据很小，最慢的试除法应该也可以过的⑧。</p><p>最后输出答案就可以了。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre class=" language-c++"><code class="language-c++">#include "iostream"#include "cstdio"#include "cstring"using namespace std;int len, cnt[30], ans;bool v[105];char s[105];void primes(int n){    memset(v, 0, sizeof(v));    for (int i = 2; i <= n; i++)    {        if (v[i])            continue;        for (int j = i; j < n / i; j++)            v[i * j] = 1;    }}int main(){    scanf("%s", s);    len = strlen(s);    for (int i = 0; i < len; i++)        cnt[s[i] - 'a']++;    int ma = -1, mi = 1000;    for (int i = 1; i <= 26; i++)    {        if (cnt[i] > ma)            ma = cnt[i];        if (cnt[i] < mi && cnt[i] != 0)            mi = cnt[i];    }    ans = ma - mi;    primes(105);    v[0] = v[1] = 1;    if (!v[ans])    {        cout << "Lucky Word" << endl;        cout << ans << endl;    }    else    {        cout << "No Answer" << endl;        cout << "0" << endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 信息竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019.7.31CodeChef刷题记录</title>
      <link href="/2019.7.31CodeChef%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2019.7.31CodeChef%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="2019-7-31CodeChef做题记录"><a href="#2019-7-31CodeChef做题记录" class="headerlink" title="2019.7.31CodeChef做题记录"></a>2019.7.31CodeChef做题记录</h2><p>今天切了好几道CodeChef上的题，不是很难，但很好练代码。爽。</p><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>传送门：<a href="https://vjudge.net/problem/CodeChef-XENTASK" target="_blank" rel="noopener">XENTASK</a></p><p>大水题，累加xanny的奇数号和yana的偶数号作为 $sum1$ 累加xanny的偶数号和yana的奇数号作为 $sum2$ 比较两者输出小的就好惹qwq。</p><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<cstdio>#include<cstring>using namespace std;const int N=2e4+5;int T,n,a;long long sum1,sum2;inline int get(){    int res=0;char c=getchar();    while(c<'0'||c>'9') c=getchar();    while(c>='0'&&c<='9') res=res*10+c-'0',c=getchar();    return res;}int main(){    T=get();    while(T--)    {        n=get();        sum1=sum2=0;        for(int i=1;i<=n;i++)        {            a=get();            if(i%2) sum1+=a;            else sum2+=a;        }        for(int i=1;i<=n;i++)        {            a=get();            if(i%2) sum2+=a;            else sum1+=a;        }        cout<<min(sum1,sum2)<<endl;    }    return 0;}</code></pre><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>传送门：</p><p><a href="https://vjudge.net/problem/CodeChef-EXTRAN" target="_blank" rel="noopener">EXTRAN</a></p><p>大水题。对序列从小到大排序，找到重复的或者隔开的输出这个就可以惹qwq</p><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<cstdio>#include<cstring>#include<algorithm>using namespace std;const int N=1e5+5;int T,n,a[N];inline int get(){    int res=0;char c=getchar();    while(c<'0'||c>'9') c=getchar();    while(c>='0'&&c<='9') res=res*10+c-'0',c=getchar();    return res;}int main(){    T=get();    while(T--)    {        n=get();        for(int i=1;i<=n;i++) a[i]=get();        sort(a+1,a+n+1);        for(int i=1;i<=n;i++)        {            if(a[i]==a[i+1])            {                printf("%d\n",a[i]);                break;            }            if(a[i+1]!=a[i]+1)            {                if(i==1) printf("%d\n",a[i]);                else printf("%d\n",a[i+1]);                break;            }        }    }    return 0;}</code></pre><h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>传送门：</p><p><a href="https://vjudge.net/problem/CodeChef-SCHEDULE" target="_blank" rel="noopener">SCHEDULE</a></p><p>有点难度qwq</p><p>先用字符串存储这个01串，开一个数组记录所有连续的块的长度。先特判$k$能够修改所有0或1的情况，如果可以，直接输出1。否则二分最大连续天数，扫描每个连续的块的长度，如果我们要保证最大连续天数不超过mid，也就意味着如果有块的长度大于mid，这个块的长度是mid的几倍，就要使用几次变换操作。每个连通块消耗的次数是 $len/mid$ 次，然后 $res+=len/mid$ 。扫描完后，如果 $res&gt;k$ 则天数不合法。</p><pre class=" language-c++"><code class="language-c++">#include<bits/stdc++.h>using namespace std;char a[1000010];int b[1000010],cnt,k,n;bool check(int x){    int s=0,i;    for(i=1; i<=cnt; i++)        s+=b[i]/(x+1);    return s<=k;}int main(){    int t,i,l,r,ans,mid,x;    scanf("%d",&t);    while(t--)    {        scanf("%d%d%s",&n,&k,a+1);        cnt=1;        b[1]=1;        for(i=1; i<=n; i++)        {            if(a[i]==a[i-1]) b[cnt]++;            else            {                cnt++;                b[cnt]=1;            }        }        x=0;        for(i=1; i<=n; i++)            if(a[i]-'0'==(i&1)) x++;        if(x<=k||(n-x)<=k)        {            printf("1\n");            continue;        }        l=2;        r=n;        ans=0;        while(l<=r)        {            mid=(l+r)/2;            if(check(mid)) r=mid-1,ans=mid;            else l=mid+1;        }        printf("%d\n", ans);    }    return 0;}</code></pre><h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><p>传送门：</p><p><a href="https://vjudge.net/problem/CodeChef-DISHOWN" target="_blank" rel="noopener">DISHOWN</a></p><p>woc并查集裸题！但是这里有<img src="https://ae01.alicdn.com/kf/Hac293befd6f346c8bedc2ada62e28277c.jpg" alt> 要注意的地方，就是要把值小的并到值大的上面。</p><pre class=" language-c++"><code class="language-c++">#include "iostream"#include "cstdio"#include "cstring"#include "algorithm"using namespace std;const int N=1e4+5;int n,T,q,a[N],fa[N];int find(int x){    if(x==fa[x]) return fa[x];    return fa[x]=find(fa[x]);}int main(int argc, char const *argv[]){    ios::sync_with_stdio(false);    int o,x,y;    cin>>T;    while (T--)    {        cin>>n;        for (int i = 1; i <= n; i++) cin>>a[i];        cin>>q;        for (int i = 1; i <= n; i++) fa[i]=i;        while (q--)        {            cin>>o;            if(o)            {                cin>>x;                cout<<find(x)<<endl;                continue;            }            else            {                cin>>x>>y;                int fx=find(x),fy=find(y);                if (fx==fy)                {                    cout<<"Invalid query!"<<endl;                    continue;                }                else                {                    if (a[fx]>a[fy]) fa[fy]=fx;                    else if (a[fx]==a[fy]) continue;                    else fa[fx]=fy;                }            }        }    }    return 0;}</code></pre><h3 id="T5"><a href="#T5" class="headerlink" title="T5"></a>T5</h3><p>传送门：</p><p><a href="https://vjudge.net/problem/CodeChef-SUMQ" target="_blank" rel="noopener">SUMQ</a></p><p>难qwq，但也不是很难，耐心推下式子大概就能搞定。</p><p>首先把三个序列从小到大排序。如果 $x_i&gt;y_j$ 且 $x_{i-1}\geq y_j$ ，那么显然 $x_{1…i-1}$ 都小于$y_j$  ，同样的，对 $z_i$ 也是如此。</p><p>我们设 $mx_i,mz_i$ 分别表示 $y$ 取 $y_i$ 时，$x$ 和 $z$ 取最大值时的下标。</p><p>推式子，可得<br>$$<br>ans=\Sigma_{i=1}^{q}(\Sigma_{j=1}^{mz_j}z_i+mz_i<em>y_i)</em>(\Sigma_{j=1}^{mx_j}+mx_i*y_i)<br>$$<br>用前缀和维护即可。</p><pre class=" language-c++"><code class="language-c++">#include "iostream"#include "cstdio"#include "cstring"#include "algorithm"using namespace std;const int N=100005;const int mod=1000000007;long long t,p,q,r,ans,x[N],y[N],z[N],mx[N],mz[N];inline long long get(){    long long res=0;char c = getchar();    while (c < '0'||c > '9') c = getchar();    while (c >= '0'&&c <= '9') res = res * 10 + c - '0',c = getchar();    return res;}int main(int argc, char const *argv[]){    t=get();    while (t--)    {        ans=0;        p=get(), q=get(), r=get();        for (int i = 1; i <= p; i++) x[i] = get();        for (int i = 1; i <= q; i++) y[i] = get();        for (int i = 1; i <= r; i++) z[i] = get();        sort (x+1 ,x+p+1);        sort (y+1 ,y+q+1);        sort (z+1 ,z+r+1);        for (int i = 1; i <= p; i++) x[i] += x[i-1];        for (int i = 1; i <= q; i++) y[i] += y[i-1];        for (int i = 1; i <= r; i++) z[i] += z[i-1];        for (int i = 1; i <= q; i++) mx[i]=p,mz[i]=r;        for (int i = 1; i <= q; i++)        {            for (int j = 1; j <= p; j++)                if (x[j] - x[j-1] > y[i]) mx[i] = j;            for (int j = 1; j <= r; j++)                if (z[j] - z[j-1] > y[i]) mz[i] = j;        }        for (int i = 1; i <= q; i++)        {            ans=(ans + ((mz[i] * y[i] + z[mz[i]]) * (x[mx[i]] + mx[i] * y[i])) % mod) % mod;            cout<<ans<<endl;        }    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 信息竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 做题记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>灯泡（清华集训2015）题解</title>
      <link href="/%E7%81%AF%E6%B3%A1%EF%BC%88%E6%B8%85%E5%8D%8E%E9%9B%86%E8%AE%AD2015%EF%BC%89%E9%A2%98%E8%A7%A3/"/>
      <url>/%E7%81%AF%E6%B3%A1%EF%BC%88%E6%B8%85%E5%8D%8E%E9%9B%86%E8%AE%AD2015%EF%BC%89%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><p>Compared to wildleopard’s wealthiness, his brother mildleopard is rather poor. His house is narrow and he has only one light bulb in his house. Every night, he is wandering in his incommodious house, thinking of how to earn more money. One day, he found that the length of his shadow was changing from time to time while walking between the light bulb and the wall of his house. A sudden thought ran through his mind and he wanted to know the maximum length of his shadow.</p><h1 id="Intput"><a href="#Intput" class="headerlink" title="Intput"></a>Intput</h1><p>The first line of the input contains an integer T (T &lt;= 100), indicating the number of cases.</p><p>Each test case contains three real numbers H, h and D in one line. H is the height of the light bulb while h is the height of mildleopard. D is distance between the light bulb and the wall. All numbers are in range from 10-2 to 103, both inclusive, and H - h &gt;= 10-2.</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each test case, output the maximum length of mildleopard’s shadow in one line, accurate up to three decimal places..</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>3</p><p>2 1 0.5</p><p>2 0.5 3</p><p>4 3 4</p><p><strong>Sample Output</strong></p><p>1.000</p><p>0.750</p><p>4.000</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>这道题是一道三分的经典例题，<del>但我就是不用三分</del>，我用数学。</p><p>首先影子的长度可以分为两个部分：影子有的在墙上的时候和全不在墙上的时候。<br>在第二种情况比较简单，通过相似三角形的知识可以得出一个一次函数。<br>第一种情况，仔细想想，恍然大悟，显然是一个双勾函数。</p><p>把整个房间想象成一个平面直角坐标系，设灯泡坐标为（0，H）。我们定义一个函数shadow.表示影子长度关于人坐标与灯泡的水平距离的函数。我们可以求出一个值sw，表示当影子正好处于墙角位置时，人与灯泡的水平距离，即x.</p><p>那么，怎么求影子的最大值呢？</p><p>前面已经讲了，影子的长度shadow关于x分为两段函数。sw就是其分界点，在D,H,h已知的情况下，可以轻易得出其函数解析式以及最值。最后要注意函数的定义域为[0,D].</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cstdio></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cmath></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> T<span class="token punctuation">;</span><span class="token keyword">double</span> H<span class="token punctuation">,</span>h<span class="token punctuation">,</span>D<span class="token punctuation">,</span>sw<span class="token punctuation">,</span>ans<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//sw是影子刚好到墙角时，人到灯泡水平距离 </span><span class="token comment" spellcheck="true">//大概分为两部分：影子到了墙上和没到墙上，分两种方法计算</span><span class="token keyword">double</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">double</span> y<span class="token operator">=</span><span class="token operator">-</span><span class="token punctuation">(</span>x<span class="token operator">+</span>D<span class="token operator">*</span><span class="token punctuation">(</span>H<span class="token operator">-</span>h<span class="token punctuation">)</span><span class="token operator">/</span>x<span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">(</span>D<span class="token operator">+</span>H<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//第二段函数计算</span>    <span class="token keyword">return</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">double</span> <span class="token function">shadow</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//全题最难部分：计算影子长度 x是站的位置距灯泡水平距离 </span><span class="token punctuation">{</span>    <span class="token keyword">double</span> s<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">&lt;</span>sw<span class="token punctuation">)</span> s<span class="token operator">=</span><span class="token punctuation">(</span>h<span class="token operator">*</span>x<span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span>H<span class="token operator">-</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//第一段函数计算</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">==</span>sw<span class="token punctuation">)</span> s<span class="token operator">=</span>D<span class="token operator">-</span>sw<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">></span>sw<span class="token punctuation">)</span> s<span class="token operator">=</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>T<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lf%lf%lf%"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>H<span class="token punctuation">,</span><span class="token operator">&amp;</span>h<span class="token punctuation">,</span><span class="token operator">&amp;</span>D<span class="token punctuation">)</span><span class="token punctuation">;</span>        sw<span class="token operator">=</span>D<span class="token operator">-</span><span class="token punctuation">(</span>h<span class="token operator">*</span>D<span class="token operator">/</span>H<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">double</span> tem1<span class="token punctuation">,</span>temp<span class="token punctuation">,</span>tem2<span class="token punctuation">;</span>        tem1<span class="token operator">=</span><span class="token function">shadow</span><span class="token punctuation">(</span>sw<span class="token punctuation">)</span><span class="token punctuation">;</span>        temp<span class="token operator">=</span><span class="token function">sqrt</span><span class="token punctuation">(</span>D<span class="token operator">*</span><span class="token punctuation">(</span>H<span class="token operator">-</span>h<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//第二段函数的最值。</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>D<span class="token operator">&lt;</span>temp<span class="token punctuation">)</span> tem2<span class="token operator">=</span><span class="token function">shadow</span><span class="token punctuation">(</span>D<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//规范定义域，如“勾点”在定义域外，显然这段函数是单调递增的，最大值即为shadow(D)</span>        <span class="token keyword">else</span> tem2<span class="token operator">=</span><span class="token function">shadow</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>        ans<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>tem1<span class="token punctuation">,</span>tem2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.3f\n"</span><span class="token punctuation">,</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Retr 0;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 信息竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P1135 【奇怪的电梯】</title>
      <link href="/%E9%A2%98%E8%A7%A3%20P1135%20%E3%80%90%E5%A5%87%E6%80%AA%E7%9A%84%E7%94%B5%E6%A2%AF%E3%80%91/"/>
      <url>/%E9%A2%98%E8%A7%A3%20P1135%20%E3%80%90%E5%A5%87%E6%80%AA%E7%9A%84%E7%94%B5%E6%A2%AF%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这是一道难度较低的搜索题目，很明显可以选择BFS或DFS来做，我用的是dfs;</p><p>先从a层开始搜索，我们把去过的每一层都进行标记，以免重复。对于每一层，我们可以选择向上还是向下走，如果越界或是能去的楼层已经标记，就不去了。假如已经到了目标楼层b，就用res尝试更新答案。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">250</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> inf <span class="token operator">=</span> <span class="token number">0x3f3f3f3f</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> ans <span class="token operator">=</span> inf<span class="token punctuation">,</span> num<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">bool</span> vis<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> res<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> b<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        ans <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">&lt;</span> ans<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        vis<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">+</span> num<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> n <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>vis<span class="token punctuation">[</span>k <span class="token operator">+</span> num<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>k <span class="token operator">+</span> num<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> res <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">-</span> num<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>vis<span class="token punctuation">[</span>k <span class="token operator">-</span> num<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token function">dfs</span><span class="token punctuation">(</span>k <span class="token operator">-</span> num<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> res <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果向上或向下不越界，且相应层数没有访问过，则往该方向搜索；</span>        vis<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 回溯；</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vis<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ans <span class="token operator">&lt;</span> inf<span class="token punctuation">)</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"-1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 无解时，不会更新答案，ans=inf ，输出-1；</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 信息竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P3942 【将军令】</title>
      <link href="/%E9%A2%98%E8%A7%A3%20P3942%20%E3%80%90%E5%B0%86%E5%86%9B%E4%BB%A4%E3%80%91/"/>
      <url>/%E9%A2%98%E8%A7%A3%20P3942%20%E3%80%90%E5%B0%86%E5%86%9B%E4%BB%A4%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><h3 id="思路：贪心"><a href="#思路：贪心" class="headerlink" title="思路：贪心"></a>思路：贪心</h3><p>看了许多大佬的题解，都没有很详细的理论分析，所以我结合网上的写了理论证明。</p><p>在看做法之前，我们先明白两个引理。</p><p><strong>引理 1</strong>：在以 Pk 为根的子树中，至少要选择一个结点带小队。 </p><p>因为 P 距小队的距离不能超过 k，而所有与 P 距离不超过 k 的结点都在以 Pk 为根的子树，所以引理 1 成立。</p><p>现在我们知道了一棵子树中至少有一个小队，进一步，我们需要找到在哪个结点安排小队。</p><p><strong>引理 2</strong>：在 Pk 结点上安排小队不会比在其子孙结点上安排小队差。 </p><p>如果一个结点 A 与一个有小队的结点距离不超过 k，我们称 A 被 B 覆盖。我们知道， P 是整棵树深度最大的结点,它也是以 Pk 为根的子树中深度最大的结点。这样，在 Pk 放小队，整棵子树中的结点都被 Pk 覆盖。设我们在 Q 建立一个小队，它在 Pk 的 子树中不可能比 Pk 覆盖更多的结点，考虑 Pk 子树外的一个结点 R，Q 与 R 的最短路径必然经过 Pk，因此 Pk 到 R 的距离不会比 Q 到 R 的距离远。这样 Pk 在子树外能覆盖的结点不会 比 Q 在子树外部覆盖的结点少。因此，总体来说，选 Pk 都不会比选 Q 差。 这样，从最优的决策出发，我们必然要选择 Pk 建立安排小队。</p><p>好了，既然已经证明了就好办了。</p><p>把节点按深度存，先从最深的开始，找没小队且存在的最高的父亲，再dfs染上色。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"iostream"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"cstdio"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"cstring"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"queue"</span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"vector"</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1e5</span> <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> k<span class="token punctuation">,</span> t<span class="token punctuation">,</span> tot<span class="token punctuation">,</span> maxdep <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> ans<span class="token punctuation">;</span><span class="token keyword">int</span> head<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> ver<span class="token punctuation">[</span>N <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nxt<span class="token punctuation">[</span>N <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> fa<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> dep<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> deep<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">bool</span> color<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> is<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>c <span class="token operator">&lt;</span> <span class="token string">'0'</span> <span class="token operator">||</span> c <span class="token operator">></span> <span class="token string">'9'</span><span class="token punctuation">)</span>        c <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>c <span class="token operator">>=</span> <span class="token string">'0'</span> <span class="token operator">&amp;&amp;</span> c <span class="token operator">&lt;=</span> <span class="token string">'9'</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        res <span class="token operator">=</span> res <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> c <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">;</span>        c <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>    ver<span class="token punctuation">[</span><span class="token operator">++</span>tot<span class="token punctuation">]</span> <span class="token operator">=</span> y<span class="token punctuation">;</span>    nxt<span class="token punctuation">[</span>tot<span class="token punctuation">]</span> <span class="token operator">=</span> head<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>    head<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> tot<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> f<span class="token punctuation">)</span><span class="token punctuation">{</span>    fa<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">;</span>    dep<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> dep<span class="token punctuation">[</span>f<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    deep<span class="token punctuation">[</span>dep<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>    maxdep <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxdep<span class="token punctuation">,</span> dep<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> e <span class="token operator">=</span> head<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span> e<span class="token punctuation">;</span> e <span class="token operator">=</span> nxt<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> v <span class="token operator">=</span> ver<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">==</span> f<span class="token punctuation">)</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> u<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">paint</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> f<span class="token punctuation">,</span> <span class="token keyword">int</span> al<span class="token punctuation">)</span><span class="token punctuation">{</span>    color<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>al <span class="token operator">==</span> s<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> e <span class="token operator">=</span> head<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span> e<span class="token punctuation">;</span> e <span class="token operator">=</span> nxt<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> v <span class="token operator">=</span> ver<span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">==</span> f<span class="token punctuation">)</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token function">paint</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> s<span class="token punctuation">,</span> x<span class="token punctuation">,</span> al <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> father<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> maxdep<span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> deep<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            father <span class="token operator">=</span> deep<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>color<span class="token punctuation">[</span>father<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> k<span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> p <span class="token operator">&lt;=</span> j<span class="token punctuation">;</span> p<span class="token operator">++</span><span class="token punctuation">)</span>                    father <span class="token operator">=</span> fa<span class="token punctuation">[</span>father<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>father <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> is<span class="token punctuation">[</span>father<span class="token punctuation">]</span><span class="token punctuation">)</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token function">paint</span><span class="token punctuation">(</span>father<span class="token punctuation">,</span> k<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                is<span class="token punctuation">[</span>father<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">freopen</span><span class="token punctuation">(</span><span class="token string">"testdata.in"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">freopen</span><span class="token punctuation">(</span><span class="token string">"test.out"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    n <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> t <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        x <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">add</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">solve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>is<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            ans<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>color<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        ans<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> ans<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 信息竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P1828 【香甜的黄油 Sweet Butter】</title>
      <link href="/%E9%A2%98%E8%A7%A3%20P1828%20%E3%80%90%E9%A6%99%E7%94%9C%E7%9A%84%E9%BB%84%E6%B2%B9%20Sweet%20Butter%E3%80%91/"/>
      <url>/%E9%A2%98%E8%A7%A3%20P1828%20%E3%80%90%E9%A6%99%E7%94%9C%E7%9A%84%E9%BB%84%E6%B2%B9%20Sweet%20Butter%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h1 id="SPFA最短路无STL"><a href="#SPFA最短路无STL" class="headerlink" title="SPFA最短路无STL"></a>SPFA最短路无STL</h1><p>本蒟蒻看楼上一群大佬用STL写SPFA，就想着用普通的SPFA写一篇题解。<br>看题目也知道，如果只是朴素的FLOYED肯定是会超时的，所以这里考虑使用最快的SPFA算法。<br>话不多说，上代码~~</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cstdio></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cstring></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std；<span class="token keyword">int</span> n<span class="token punctuation">,</span>p<span class="token punctuation">,</span>c<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>t<span class="token punctuation">,</span>min1<span class="token punctuation">,</span>head<span class="token punctuation">,</span>tail<span class="token punctuation">,</span>tot<span class="token punctuation">,</span>u<span class="token punctuation">;</span>inta<span class="token punctuation">[</span><span class="token number">801</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">801</span><span class="token punctuation">]</span><span class="token punctuation">,</span>b<span class="token punctuation">[</span><span class="token number">501</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dis<span class="token punctuation">[</span><span class="token number">801</span><span class="token punctuation">]</span><span class="token punctuation">,</span>num<span class="token punctuation">[</span><span class="token number">801</span><span class="token punctuation">]</span><span class="token punctuation">,</span>w<span class="token punctuation">[</span><span class="token number">801</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">801</span><span class="token punctuation">]</span><span class="token punctuation">,</span>team<span class="token punctuation">[</span><span class="token number">1601</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">bool</span> exist<span class="token punctuation">[</span><span class="token number">801</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cin<span class="token operator">>></span>n<span class="token operator">>></span>p<span class="token operator">>></span>c<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>p<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>p<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>            w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0x7fffffff</span><span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//初始化</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        cin<span class="token operator">>></span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>c<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">//邻接矩阵存储</span>    <span class="token punctuation">{</span>        cin<span class="token operator">>></span>x<span class="token operator">>></span>y<span class="token operator">>></span>t<span class="token punctuation">;</span>        w<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">=</span>w<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span>t<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//双向</span>        a<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">++</span>num<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span>y<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//存储于每个牧场相连的牧场序号</span>        a<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">++</span>num<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span>x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    min1<span class="token operator">=</span><span class="token number">0x7fffffff</span><span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>p<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>p<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> dis<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0x7fffffff</span><span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token function">memset</span><span class="token punctuation">(</span>team<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>team<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//队列数组初始化memset(exist,false,sizeof(exist)); //标记数组初始化</span>dis<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>team<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>head<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>tail<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>exist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//起始点入队</span>        <span class="token keyword">do</span>        <span class="token punctuation">{</span>            head<span class="token operator">++</span><span class="token punctuation">;</span>            head<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">(</span>head<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">1601</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//循环队列，有效节约空间</span>            u<span class="token operator">=</span>team<span class="token punctuation">[</span>head<span class="token punctuation">]</span><span class="token punctuation">;</span>            exist<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>num<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//循环判断每一个与头相连的点</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>dis<span class="token punctuation">[</span>a<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">></span>dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>a<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    dis<span class="token punctuation">[</span>a<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span>dis<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>a<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>exist<span class="token punctuation">[</span>a<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//入队操作</span>                    <span class="token punctuation">{</span>                        tail<span class="token operator">++</span><span class="token punctuation">;</span>                        tail<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">(</span>tail<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">1601</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                        team<span class="token punctuation">[</span>tail<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                        exist<span class="token punctuation">[</span>a<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span>head<span class="token operator">!=</span>tail<span class="token punctuation">)</span><span class="token punctuation">;</span>        tot<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        tot<span class="token operator">+</span><span class="token operator">=</span>dis<span class="token punctuation">[</span>b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>tot<span class="token operator">&lt;</span>min1<span class="token punctuation">)</span> min1<span class="token operator">=</span>tot<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout<span class="token operator">&lt;&lt;</span>min1<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 信息竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P1201 【[USACO1.1]贪婪的送礼者Greedy Gift Givers】</title>
      <link href="/%E9%A2%98%E8%A7%A3%20P1201%20%E3%80%90%5BUSACO1.1%5D%E8%B4%AA%E5%A9%AA%E7%9A%84%E9%80%81%E7%A4%BC%E8%80%85Greedy%20Gift%20Givers%E3%80%91/"/>
      <url>/%E9%A2%98%E8%A7%A3%20P1201%20%E3%80%90%5BUSACO1.1%5D%E8%B4%AA%E5%A9%AA%E7%9A%84%E9%80%81%E7%A4%BC%E8%80%85Greedy%20Gift%20Givers%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p>简单题就是要有简单题的亚子</p><p>数据十分小，可以暴力。</p><p>先开结构体存下每个人的名字，收入和支出，按顺序读入。</p><p>输入送礼名单时，遍历一遍，匹配名字，加上平均数。</p><p>最后按顺序输出每个人的收入-支出</p><p>详细见代码。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cstdio></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cstring></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;string></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">;</span>string b<span class="token punctuation">;</span><span class="token keyword">struct</span> node<span class="token punctuation">{</span>    string name<span class="token punctuation">;</span>    <span class="token keyword">int</span> in<span class="token punctuation">,</span>out<span class="token punctuation">;</span><span class="token punctuation">}</span> a<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> cin<span class="token operator">>></span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cin<span class="token operator">>></span>b<span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>x<span class="token punctuation">,</span><span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>y<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//除数不能为0</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token operator">==</span>b<span class="token punctuation">)</span>           <span class="token comment" spellcheck="true">//string就是方便</span>                a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>out<span class="token operator">+</span><span class="token operator">=</span><span class="token punctuation">(</span>x<span class="token operator">/</span>y<span class="token punctuation">)</span><span class="token operator">*</span>y<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//平均送礼</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>y<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            cin<span class="token operator">>></span>b<span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token operator">==</span>b<span class="token punctuation">)</span>                    a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>in<span class="token operator">+</span><span class="token operator">=</span>x<span class="token operator">/</span>y<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//到账</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        cout<span class="token operator">&lt;&lt;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>in<span class="token operator">-</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>out<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 信息竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解P3941【入阵曲】</title>
      <link href="/%E9%A2%98%E8%A7%A3P3941%E3%80%90%E5%85%A5%E9%98%B5%E6%9B%B2%E3%80%91/"/>
      <url>/%E9%A2%98%E8%A7%A3P3941%E3%80%90%E5%85%A5%E9%98%B5%E6%9B%B2%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="60分做法：暴力-前缀和"><a href="#60分做法：暴力-前缀和" class="headerlink" title="60分做法：暴力+前缀和"></a>60分做法：暴力+前缀和</h3><p>使用前缀和存储 <code>sum[i][j]</code> 存储<code>(i,j)</code>点作为右下角<code>(1,1)</code>作左上角的矩阵和。可以枚举每个矩阵大小。复杂度$O(n^4)$</p><h3 id="100分做法：找规律-小暴力"><a href="#100分做法：找规律-小暴力" class="headerlink" title="100分做法：找规律+小暴力"></a>100分做法：找规律+小暴力</h3><p>先看样例：</p><table><thead><tr><th align="center">1</th><th align="center">2</th><th align="center">1</th></tr></thead><tbody><tr><td align="center">2</td><td align="center">1</td><td align="center">2</td></tr></tbody></table><p>我们可以尝试枚举行之间的分割线，<code>(i,j)</code>代i为上界，以j为下界的矩阵。对这样一个矩阵进行压行处理。就是把每一列的数字都加起来，得到：</p><table><thead><tr><th align="center">3</th><th align="center">3</th><th align="center">3</th></tr></thead><tbody><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>这样一个序列。我们用一个数组<code>f</code>存储它的前缀和，再用<code>mod</code>数组存储它模k的数。我们设<code>f[i],f[j]</code>，且<code>i&lt;j</code>。假如，<code>mod[f[i]]==mod[f[j]]</code>那么就代表区间<code>(i,j)</code>的和%k==0。因为<code>mod[f[i]]</code>区间<code>(i,j)</code>没有对余数做出改变。</p><p>所以，我们应该使用一个桶，<code>cnt[i]</code>代表此前模k=i的前缀和个数，再出现一个模k=i的前缀和时，我们先在答案加上<code>cnt[i]</code>再<code>cnt[i]++</code>。时间复杂度：$O(n^3)$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-c++"><code class="language-c++">#include "iostream"#include "cstdio"#include "algorithm"#define ll long longusing namespace std;const int N = 405;const int M = 1000005;int n, m, k, a[N][N];ll ans, sum[N][N], mod[M], cnt[M], f[N];inline int get(){    int res = 0, sign = 1;    char c = getchar();    while (c < '0' || c > '9')    {        if (c == '-')            sign = -1;        c = getchar();    }    while (c >= '0' && c <= '9')    {        res = res * 10 + c - '0';        c = getchar();    }    return res * sign;}int main(int argc, char const *argv[]){    n = get(), m = get(), k = get();    for (int i = 1; i <= n; i++)        for (int j = 1; j <= m; j++)        {            a[i][j] = get();            sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + a[i][j];        }    for (int i = 0; i < n; i++)        for (int j = i + 1; j <= n; j++)        {            cnt[0] = 1;            for (int p = 1; p <= m; p++)            {                f[p] = (sum[j][p] - sum[i][p]) % k;                ans += cnt[f[p]];                cnt[f[p]]++;            }            for (int p = 1; p <= m; p++)                cnt[f[p]] = 0;        }    cout << ans << endl;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 信息竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P1196 【[NOI2002]银河英雄传说】</title>
      <link href="/%E9%A2%98%E8%A7%A3%20P1196%20%E3%80%90%5BNOI2002%5D%E9%93%B6%E6%B2%B3%E8%8B%B1%E9%9B%84%E4%BC%A0%E8%AF%B4%E3%80%91/"/>
      <url>/%E9%A2%98%E8%A7%A3%20P1196%20%E3%80%90%5BNOI2002%5D%E9%93%B6%E6%B2%B3%E8%8B%B1%E9%9B%84%E4%BC%A0%E8%AF%B4%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h2 id="算法：带权并查集"><a href="#算法：带权并查集" class="headerlink" title="算法：带权并查集"></a>算法：带权并查集</h2><p>这道题有两种算法，但主要思想都是并查集，区别在于是否有路径压缩。</p><h4 id="1-不带路径压缩"><a href="#1-不带路径压缩" class="headerlink" title="1. 不带路径压缩"></a>1. 不带路径压缩</h4><p>  此时fa[x]就表示排在第x号战舰前面的那个战舰的编号。集合的“代表”就是最前面的战舰的编号。<br>  让树上每条边带上权值1，这样树上两点之间的距离-1就是二者相隔的战舰数量。<br>  注意，这样写的话在find函数中就不能加上路径压缩的优化。</p><h4 id="2-带路径压缩"><a href="#2-带路径压缩" class="headerlink" title="2.带路径压缩"></a>2.带路径压缩</h4><p>  在考虑路径压缩时，我们应该在建立一个数组d，d[x]记录战舰x与fa[x]之间的边的权值。<br>  我们知道，在路径压缩时，会把x指向此时的树根。我们应该对find函数做一些修改，把d[x]更新为从x到树根的路径上的所有边权之和。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">==</span>f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> root<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    d<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">+</span><span class="token operator">=</span>d<span class="token punctuation">[</span>f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span>root<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>  当接收到Cxy指令时，分别执行find(x),find(y)完成查询和路径压缩。如果两者的返回值相同，则说明x,y在同一列之中。<br>  那么，d[x]和d[y]都指向了共同的树根，分别表示在x，y之前的战舰数量。二者之差再减1就是x和y之间间隔的战舰数量。<br>  当接收到Mxy指令时，把x的树根作为y的树根的子节点，连接的新边的权值应给设为合并之前集合y的大小。（因为y集合全部排在x之前）<br>  因此还需要增加一个size数组记录每个集合的大小。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>    x<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>y<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>    f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span>y<span class="token punctuation">;</span>d<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span>size<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>    size<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">+</span><span class="token operator">=</span>size<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>下面是完整代码</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cstdio></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cmath></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> N<span class="token operator">=</span><span class="token number">30000</span><span class="token punctuation">;</span><span class="token keyword">int</span> t<span class="token punctuation">,</span>f<span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>d<span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>size<span class="token punctuation">[</span>N<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">==</span>f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> root<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    d<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">+</span><span class="token operator">=</span>d<span class="token punctuation">[</span>f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span>root<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>    x<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>y<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>    f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span>y<span class="token punctuation">;</span>d<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">=</span>size<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>    size<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">+</span><span class="token operator">=</span>size<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cin<span class="token operator">>></span>t<span class="token punctuation">;</span>    <span class="token keyword">char</span> o<span class="token punctuation">;</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>        d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        size<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>t<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cin<span class="token operator">>></span>o<span class="token operator">>></span>i<span class="token operator">>></span>j<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>o<span class="token operator">==</span><span class="token string">'M'</span><span class="token punctuation">)</span> <span class="token function">merge</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>o<span class="token operator">==</span><span class="token string">'C'</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> x<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token function">find</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">!=</span>y<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                cout<span class="token operator">&lt;&lt;</span><span class="token string">"-1"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                <span class="token keyword">int</span> q<span class="token operator">=</span><span class="token function">abs</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>d<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                cout<span class="token operator">&lt;&lt;</span>q<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 信息竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 luogu P1455 【搭配购买】</title>
      <link href="/%E9%A2%98%E8%A7%A3%20P1455%20%E3%80%90%E6%90%AD%E9%85%8D%E8%B4%AD%E4%B9%B0%E3%80%91/"/>
      <url>/%E9%A2%98%E8%A7%A3%20P1455%20%E3%80%90%E6%90%AD%E9%85%8D%E8%B4%AD%E4%B9%B0%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h2 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h2><p>​    正解十分简单。所有互相有关联的云可以视作捆绑销售，使用并查集合在一起，得到若干个由原来的物品组成的新物品，最后跑01背包即可。</p><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<cstdio>#include<cstring>using namespace std;const int N=10005;int n,m,w,val[N],wor[N],f[N],fa[N];int p[N],v[N],id[N],tot;bool vis[N];inline int get(){    int res=0;char c=getchar();    while(c<'0'||c>'9') c=getchar();    while(c>='0'&&c<='9')    {        res=res*10+c-'0';        c=getchar();    }    return res;}int find(int x){    if(x==fa[x]) return x;    else return fa[x]=find(fa[x]);}int main(){    n=get(),m=get(),w=get();    for(int i=1;i<=n;i++)        wor[i]=get(),val[i]=get();    for(int i=1;i<=n;i++) fa[i]=i;    int x,y,fi;    for(int i=1;i<=m;i++)    {        x=get(),y=get();        int fx=find(x),fy=find(y);        if(fx!=fy) fa[fx]=fy;    }    for(int i=1;i<=n;i++)    {        fi=find(i);        if(!vis[fi])        {            tot++;            id[fi]=tot;            v[tot]+=val[i];            p[tot]+=wor[i];            vis[fi]=true;        }        else        {            v[id[fi]]+=val[i];            p[id[fi]]+=wor[i];        }    }    for(int i=1;i<=tot;i++)        for(int j=w;j>=p[i];j--)            f[j]=max(f[j],f[j-p[i]]+v[i]);    int ans=0;    for(int i=0;i<=w;i++) ans=max(ans,f[i]);    printf("%d",ans);    return 0;}</code></pre><h2 id="来个复杂点的解法"><a href="#来个复杂点的解法" class="headerlink" title="来个复杂点的解法"></a>来个复杂点的解法</h2><p>思路：Tarjan缩点+01背包</p><p>我知道并查集就可以惹qwq，但不知为何写了个tarjan</p><p>反正思路很简单，tarjan缩点，缩出来的点就是有关系的点揉在一起的，再在新点上进行01背包。</p><pre class=" language-c++"><code class="language-c++">#include<iostream>#include<cstdio>#include<cstring>#include<cmath>#define ll long longusing namespace std;const int N=1e4+100;int c[N],d[N],cost[N],val[N];int next[N],head[N],go[N],tot;inline void add(int u,int v){    next[++tot]=head[u];head[u]=tot;go[tot]=v;    next[++tot]=head[v];head[v]=tot;go[tot]=u;}int dfn[N],st[N],low[N],co[N],col,num,top;int Tarjan(int u){    dfn[u]=low[u]=++num;    st[++top]=u;    for(int i=head[u],v;i;i=next[i]){        v=go[i];        if(!dfn[v]){            Tarjan(v);            low[u]=min(low[u],low[v]);        }else if(!co[v]){            low[u]=min(low[u],dfn[v]);        }    }    if(low[u]==dfn[u]){        co[u]=++col;        cost[col]+=c[u];        val[col]+=d[u];        while(st[top]!=u){            cost[col]+=c[st[top]];            val[col]+=d[st[top]];            co[st[top]]=col;            --top;        }        --top;    }}int f[2][N];int main(){    freopen("buy.in","r",stdin);    freopen("buy.out","w",stdout);    int n,m,w;    cin>>n>>m>>w;    for(int i=1;i<=n;i++)    scanf("%d%d",&c[i],&d[i]);    for(int i=1,u,v;i<=m;i++){        scanf("%d%d",&u,&v);        add(u,v);    }    for(int i=1;i<=n;i++)    if(!dfn[i])Tarjan(i);    memset(f,0xcf,sizeof(f));    f[0][0]=0;    for(int i=1;i<=col;i++){        for(int j=0;j<=w;j++)        f[i&1][j]=f[(i-1)&1][j];        for(int j=cost[i];j<=w;j++)        f[i&1][j]=max(f[(i-1)&1][j],f[(i-1)&1][j-cost[i]]+val[i]);    }    int ans=0;    for(int j=0;j<=w;j++)    ans=max(ans,f[col&1][j]);    cout<<ans<<endl;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 信息竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 CF475B 【Strongly Connected City】</title>
      <link href="/%E9%A2%98%E8%A7%A3%20CF475B%20%E3%80%90Strongly%20Connected%20City%E3%80%91/"/>
      <url>/%E9%A2%98%E8%A7%A3%20CF475B%20%E3%80%90Strongly%20Connected%20City%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p>​    其实只要稍加思考便可以发现一个这张图的一个特性：<strong>只要边缘的四个点是相连通的，整张图就是联通的</strong></p><p>​    根据题意，可以发现，图中的任何一个节点，都可以通过在边缘的四条边中的某个点直接抵达（一溜就到了）。</p><p>​    如果四个顶点相连通，就代表四条边缘的边上的点都可以通过顶点到达，而中间的点只要顺着所处的边的方向走一点可以到边缘，所以所有点都可以到所有点。</p><p>​    相反的，如果有四角上的顶点从相邻的四角上的顶点无法到达，也就意味着所有点都到不了这个顶点（因为只有两条边连着外面）。</p><p>​    因此只要判断四个顶点上的边方向看是否联通即可。</p><pre class=" language-c++"><code class="language-c++">#include <iostream>#include "cstdio"#include "cstring"using namespace std;int n, m, din[22], dim[22];bool ans = true;string a, b;int main(int argc, char const *argv[]){    scanf("%d%d",&n,&m);    cin>>a>>b;    for (int i = 0; i < n; i++)        if (a[i]=='>') din[i+1] = 1;    for (int i = 0; i < m; i++)        if (b[i]=='^') dim[i+1] = 1;    if (din[1] != dim[1]) ans = false;    if (din[1] == dim[m]) ans = false;    if (din[n] == dim[1]) ans = false;    if (din[n] != dim[m]) ans = false;    if (ans) cout<<"YES";    else cout<<"NO";    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 信息竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分图最大匹配</title>
      <link href="/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/"/>
      <url>/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><ul><li><p><strong>匹配</strong>：任意两条边都没有公共端点的边的集合被称为图的一组匹配。</p></li><li><p><strong>最大匹配</strong>：在二分图中，包含边数最多的一组匹配。</p></li><li><p><strong>匹配边与非匹配边</strong>：对于任意一组匹配S，属于S的边被称为匹配边，不属于S的被称为非匹配边。</p></li><li><p><strong>匹配点与非匹配点</strong>：匹配边的端点被称为匹配点，非匹配边的端点被称为非匹配点。</p></li><li><p><strong>增广路</strong>：连结两个非匹配点的路径，使得非匹配边与匹配边交替出现。</p></li><li><p><strong>完备匹配</strong>:给定一张二分图，其左部、右部端点数量都为N，如果该二分图的最大匹配包含N条匹配边，则称该二分图具有完备匹配。</p><p>接下来我们看几张图来帮助理解。</p><p><img src="https://img.renfei.org/2013/08/2.png" alt></p></li></ul><p>如图2，这是一个二分图。</p><p><img src="https://img.renfei.org/2013/08/3.png" alt></p><p>如图3，所有红色的边就是该二分图的一组<strong>匹配</strong>。很显然，两条红色的边都没有公共端点。</p><p><img src="https://img.renfei.org/2013/08/4.png" alt></p><p>再看图4，此时所有红色的边组成的也是一组匹配，而且是<strong>最大匹配</strong>，甚至还是<strong>完备匹配</strong>。因为匹配边的数量不能再多了，而且匹配边的数量和左右部端点数相同。</p><p><img src="https://img.renfei.org/2013/08/5.png" alt></p><p>如图5，又是一张二分图，红色边的是一组匹配，红色的点就是匹配点了。</p><p><img src="https://img.renfei.org/2013/08/6.png" alt></p><p>如图6，就是图5的一条增广路了，可以看到，第一个端点和最后一个端点都是非匹配点，途中经过的边是非匹配边，匹配边的方式交替的。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>关于二分图匹配的问题，最常见的应该就是求二分图的最大匹配了吧。。。</p><p>举个例子，看这张图：</p><p><img src="https://img.renfei.org/2013/08/0.png" alt></p><p>图中男女可以凑成一对的被连上了边，那我们要尽可能的促成他人的爱情，抽象出来，也就是求二分图最大匹配了。</p><p>（虽然我觉得这样的人际关系很渣，但没办法它是服务于学术的呢。。。）</p><p><img src="https://ae01.alicdn.com/kf/HTB1m7sRXbr1gK0jSZFDq6z9yVXaR.jpg" alt></p><p>为了解决这么一个<del>渣男渣女</del>问题，我们需要用到一个和这个问题一样让人感觉不太舒服的算法（笑。</p><h1 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h1><p><strong>匈牙利算法</strong>，又称<strong>增广路算法</strong>，顾名思义，运用到了增广路的性质，这里就对增广路的一些性质进行补充。</p><h3 id="增广路的性质（建议结合上面增广路的定义看）"><a href="#增广路的性质（建议结合上面增广路的定义看）" class="headerlink" title="增广路的性质（建议结合上面增广路的定义看）"></a>增广路的性质（建议结合上面增广路的定义看）</h3><ul><li>长度为奇数，这是显然的，因为是交替的嘛。</li><li>路径上第奇数号的边是非匹配边，偶数号的是匹配边。</li></ul><p>看到以上性质，你有没有明白些什么？？</p><p>没有，好，那就容我BB两句。<del>有我也要BB</del></p><p>如果我们把增广路上的每条边状态取反，就能得到一个新匹配S’，而且比原来的匹配S大了1！</p><p>进一步我们可以得到推论：</p><p>==二分图的一组匹配S是最大匹配，当且仅当图中不存在S的增广路。==</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>有了以上知识，我们可以开始看匈牙利算法的过程了：</p><ol><li>设S为空集，即所有边都是非匹配边。</li><li>寻找增广路，再把路径上所有边的匹配状态取反，得到了一个更大的匹配S’。</li></ol><p>算法的关键在于，怎么找到一条增广路。</p><p>事实上这还是挺简单的，也没啥高深思想。就是尝试给每个左部节点去找右部节点来匹配。右部节点y能与左部节点x匹配，需要满足下列条件之一：</p><ol><li>y本身就是非匹配点。此时边(x,y)本身就是一条增广路了，长度为1。</li><li>y已经和左部节点x’匹配了，但可以从x’出发找到另一个右部节点y’与之匹配。那我们就把x’和y’连上，再连x和y。这样，x-&gt;y-&gt;x’-&gt;y’就构成了一条增广路。</li></ol><p>程序方面，这里是用深度优先搜索实现的。递归地从x出发寻找增广路，如果找到了，就在回溯的同时对沿路的边进行取反。还要同时用全局vis数组来记录访问状态，避免重复搜索。</p><p>这里再推荐一个简单易懂的<a href="https://blog.csdn.net/dark_scope/article/details/8880547" target="_blank" rel="noopener">文章</a>，不清楚的同学可以再去看看。</p><p>匈牙利算法的正确性基于贪心思想，因为一旦一个点成为了匹配点，至多因为找到增广路而更换匹配对象，不会再变回非匹配点。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre class=" language-c++"><code class="language-c++">bool dfs(int x){    for(int e=head[x];e;e=nxt[e])    {        int y=ver[e];        if(vis[y]) continue;        if(!match[y]||dfs(match[y])) //match记录匹配点        {            match[y]=x;    //修改匹配点，递归查找增广路            return true;        }    }    return false;}int main(){    for(int i=1;i<=n;i++)    {        memset(vis,0,sizeof(vis));    //每次搜完记得初始化访问状态        if(dfs(i)) ans++;    }}</code></pre><h3 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h3><p>二分图匹配能适用的模型有两个要素：</p><ol><li>节点能分成两个独立的集合，每个集合内部有0条边。</li><li>每个节点只能与1条匹配边相连。</li></ol><p>同时满足以上两个要素，就该考虑使用二分图匹配了。</p>]]></content>
      
      
      <categories>
          
          <category> 信息竞赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎来到我的博客！</title>
      <link href="/%E6%AC%A2%E8%BF%8E%E9%A1%B5/"/>
      <url>/%E6%AC%A2%E8%BF%8E%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<p>这里是ZXJ_Hans的博客，我会在这里写文（不是小说），欢迎来看。</p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 欢迎 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
